## 设计需求

​		阴阳师也玩几年了，愈发觉得这个游戏属实太花时间，背单词都没有这么勤快，跟上班一样，期望有这么一个脚本可以实现全自动帮我点点点，啥也不用管，每个月拿到足够的票抽卡，永远是抽卡的时候最开心。

+ 游戏自带的小纸人不够用，小纸人单纯为了重复点击而且每天就500体力不够塞牙缝
+ 然而市面上的脚本与小纸人类型一致都是单纯的为了点几次，再者没能有源码对个人而言是不安全的

即需要满足 高防封和高扩展性

## 设计逻辑

**信息获取，逻辑判断，操作控制 **

任何自动化脚本都可以归入这三类逻辑组合，这个是一个信息的反馈循环。

类比人，信息获取即从游戏中得到图像声音震动等等。

对于操作控制来说，一、行为具有不可控性，所有控制可以抽象为行为+反馈
反馈的具象化就是前面的截屏与分析；二、所有的异常可以理解为我的正常操作没有在预期时间内得到正确的反馈

**抽象出task**

任何一项游戏操作都可以看成一个任务，面对繁多的任务我们又抽出group这个更上层概念，用来归类分类task，我们对task的界定：每一个操作不可被分割的执行单元，即当task拆分前后不可正常运行，不可被其他task抢占。

**task实现**

鉴于状态机模式在游戏设计中是运用比较广泛的设计模式，我们很大程度参考该思维方式，同时考虑到脚本是一个不断更新迭代的软件，会有很多新的需求，期望赋予其更高的扩展性，将task内容与程序进行解耦，这也是很多xx精灵的思路

**状态机**

一般的状态机有现态，次态，事件，动作四个要素，在此基础上我们得到state event action和transitionAction这四个基础的东西，每个状态下都有event输入和action输出，而transitionAction是一种特殊的action，他表征又一个状态过度到另一个状态，每一个状态机都有起始态goto和结束态goback：起始态表示从庭院或者其他地方达到要干活的游戏界面，由程序触发启动，而结束态表示从其他游戏界面返回庭院的过程，返回庭院后结束该状态等待下一个任务

**控制器**

使用观测者模式，用于控制如何从现态跳转的次态，以及事件和动作之间的联系。观测者模式也称订阅发布模式，一种很常见的消息传递机制，一个生活的例子：你关注的某个微信公众号，当该公众号发布消息时可以第一时间知道。由event发出由action接受并执行是最核心的机制，所以我们也需要连接event action 的这么一个对象

**json**

前文提到内容与程序分离，其中的内容载体就是json文件

## 软件架构

#### 写的烂，还请海涵

****

​		首先我们来理清一下运行逻辑，软件启动之后获取配置信息连接设备->调度器开始工作：如有每周每天定时任务触发或者当前要立即执行的任务触发则把该任务push进去执行->进入任务的run->任务结束退出如果队列还有任务则继续执行下一个任务。

*我们将软件分为三大部分*：

前端与后端通信通过：信号槽和json文件进行

**前端** 使用qml和js开发

便利于用户操作，没啥的就一堆展示数据和修改数据，作者不是计算机专业的写的很烂多多包涵，我在每一个界面出定义两个数据模型，写着很麻烦。写着一半才记起来有mvp mmvc这些架构，为时已晚

**后端** 使用python

基础组件有:

+ Bridge类，这个类定义一些信号，槽。用于连接qml和python的通信，以及python内部的通信
+ Log4类，自定义的用于记录输出的类一方面可以以本地日志输出，另一方面可以实时输出到屏幕上
+ ConfigFile类，前两者都是单例模式但是这个不是，这个是读写各种配置的接口基本都是要读写什么文件再去写

设备组件：

+ DeviceType类，用于控制设备（指安卓手机、mumu模拟器、雷电模拟器）的，其内部依赖Adb类和Handle类，分别表示安卓平台和window对游戏的控制器

核心类：

+ TaskScheduler：任务调度器
+ Task：任务类
+ Action：
+ Event：

**数据**

+ Config/setting.json是对设备的配置
+ Config/taskScheduler.json是对调度器的配置
+ 每个任务下/taskConfigUI.json 用于UI显示的数据配置
+ 每个任务下/taskConfig.json 由前者生成，软件后台进行读取运行

**线程**

+ UI线程 mainWindow
+ scheduler线程（也称后台线程）
+ task1 线程
+ task2 线程 

## 自定任务

1. 从Tasks/DefaultGroup复制文件夹Template到所需的Group文件夹，并改名字（全局唯一的名字）
2. 启动软件菜单栏点击任务列表，选择刚刚复制的然后点击右下角open,即可编辑任务
3. 可参考其他的已近编辑好的任务，每次切换状态一定要点击保存！！！**保存**
4. 中间右键可新建state，选中state右键即可删除。同理右边菜单栏右键即可new一个，选中其中右键即可删除
5. 菜单栏右边第一项即整个任务的全局配置，点击即可看到
6. 从上至下为event到action。最后一项为连接event和action的，不连接的话event或者action不生效(envent2Action 是因为手敲太快打错字了不过不影响含义)
7. ！！！！**重要重要再重要**，尽量不要出现中文！！！我也不知道会出现什么问题

###### imgEvent

+ imgName：再新建这个event的时候的名字尽量同图片文字保持一致
+ x0和width：这个是为了对图片裁剪处理的限定 
+ y0和height：同样的，图片的x方向从左到右边，图片的y方向从上到下
+ 如果有这个图片，will emit signal (img) incluing position(x, y)

###### intVarEvent

+ 

###### clickAction

+ limits：这个是一个高斯随机的点击，这个是一个限制点击的范围。我们约定五种
  + imgClickS：小范围的点击 50  特别小的图片如小红叉
  + imgClickM:  一般范围点击100  
  + imgClickNormal：默认的点击150
  + imgClickL：大范围点击 200
  + imgClickXL ：超大范围点击 400  用于结算时候任意点击的图片

也可自行设定

- moveX, moveY 点击坐标中心偏移量

###### intChangeAction

###### transitionsAction

+ trigger：触发器名字，必须同建立的action名字一致，我们规定格式就是:  statexxx1_statexxx2 这样的形式
+ source：
+ dest：现态和次态

###### envent2Action

- 一一对应就完事了

！！！！！！！！！！！！**保存** 

## 规范

+ 通用的图片放在DefaultGroup/Slice

| 图片              | x0   | y0   | width | height | move          |
| ----------------- | ---- | ---- | ----- | ------ | ------------- |
| tansuo.jpg        | 0.46 | 0.13 | 0.1   | 0.2    |               |
| jiejietupo        | 0.15 | 0.84 | 0.12  | 0.16   |               |
| prepare           | 0.79 | 0.70 | 0.21  | 0.30   |               |
| hun.jpg           | 0.39 | 0.55 | 0.23  | 0.35   |               |
| fail.jpg/win.jpg  | 0.27 | 0.13 | 0.24  | 0.26   |               |
| tili              |      | 0.55 |       | 0.27   |               |
| huodejianli.jpg   |      |      |       |        | y:0.41        |
| redPoint          |      |      |       |        | x:0.04 y:0.06 |
| battle.jpg 御魂的 | 0.9  | 0.8  | 0.1   | 0.2    |               |
| gu                | 0.28 | 0.14 | 0.23  | 0.28   |               |

#### tips

+ imgEvent建立的顺序就是执行的顺序（程序在遍历的时候的顺序）
+ 可以用这个特性在单个页面选择特点的图片点击：即每一个图片定义transition一个状态，切换状态后就不会触发其他imgEvent